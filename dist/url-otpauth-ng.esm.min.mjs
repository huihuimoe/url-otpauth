const t=0,e=1,o=2,r=3,i=4,n=6,s=7,h=8,a=9;var p={INVALID_ISSUER:t,INVALID_LABEL:e,INVALID_PROTOCOL:o,MISSING_ACCOUNT_NAME:r,MISSING_COUNTER:i,MISSING_ISSUER:5,MISSING_SECRET_KEY:n,UNKNOWN_OTP:s,INVALID_DIGITS:h,UNKNOWN_ALGORITHM:a};class I extends Error{constructor(t){super(),this.name="OtpauthInvalidURL",this.errorType=t;for(const e in p)p[e]===t&&(this.message="Given otpauth:// URL is invalid. (Error "+e+")")}}const c="undefined"!=typeof URL?URL:require("url").URL,f=["totp","hotp","yaotp"],g=[6,8],w=["SHA1","SHA256","SHA512","MD5"];function l(p){const l=decodeURIComponent,u={};let d=new c(p);if("otpauth:"!==d.protocol)throw new I(o);d.protocol="ftp";const N=l((d=new c(d)).host);if(!~f.indexOf(N))throw new I(s);u.type=N;const S=d.pathname.substring(1),O=S.split(~S.indexOf(":")?":":"%3A");let L="",A="";if(1===O.length)A=l(O[0]);else{if(2!==O.length)throw new I(e);L=l(O[0]),A=l(O[1])}if(A.length<1)throw new I(r);if(2===O.length&&L.length<1)throw new I(t);u.account=A;const R=d.searchParams;if(!R.has("secret"))throw new I(n);if(u.key=R.get("secret"),R.has("issuer")&&L&&R.get("issuer")!==L)throw new I(t);if(u.issuer=R.get("issuer")||L,u.digits=6,R.has("digits")){const t=parseInt(R.get("digits"))||0;if(!~g.indexOf(t))throw new I(h);u.digits=t}if(R.has("algorithm")){if(!~w.indexOf(R.get("algorithm")))throw new I(a);u.algorithm=R.get("algorithm")}if("totp"===N&&R.has("period")&&(u.period=parseFloat(R.get("period"))||0),"hotp"===N){if(!R.has("counter"))throw new I(i);u.counter=parseInt(R.get("counter"))||0}return u}export{p as ErrorType,I as OtpauthInvalidURL,l as parse};
//# sourceMappingURL=url-otpauth-ng.esm.min.mjs.map
